{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\n\nconst EventEmitter = require('events');\n\nconst connect = require('../connection/connect');\n\nconst Connection = require('../../cmap/connection').Connection;\n\nconst common = require('./common');\n\nconst makeStateMachine = require('../utils').makeStateMachine;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst BSON = require('../connection/utils').retrieveBSON();\n\nconst makeInterruptableAsyncInterval = require('../../utils').makeInterruptableAsyncInterval;\n\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\n\nconst now = require('../../utils').now;\n\nconst sdamEvents = require('./events');\n\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\nconst kServer = Symbol('server');\nconst kMonitorId = Symbol('monitorId');\nconst kConnection = Symbol('connection');\nconst kCancellationToken = Symbol('cancellationToken');\nconst kRTTPinger = Symbol('rttPinger');\nconst kRoundTripTime = Symbol('roundTripTime');\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nfunction isInCloseState(monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\nclass Monitor extends EventEmitter {\n  constructor(server, options) {\n    super(options);\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = null;\n    this.s = {\n      state: STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 10000,\n      heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    }); // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n\n    const connectOptions = Object.assign({\n      id: '<monitor>',\n      host: server.description.host,\n      port: server.description.port,\n      bson: server.s.bson,\n      connectionType: Connection\n    }, server.s.options, this.options, // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    }); // ensure no authentication is used for monitoring\n\n    delete connectOptions.credentials;\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    } // start\n\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    this[kMonitorId].wake();\n  }\n\n  reset() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this); // restart monitor\n\n    stateTransition(this, STATE_IDLE); // restart monitoring\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS\n    });\n  }\n\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this); // close monitor\n\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n\n}\n\nfunction resetMonitorState(monitor) {\n  stateTransition(monitor, STATE_CLOSING);\n\n  if (monitor[kMonitorId]) {\n    monitor[kMonitorId].stop();\n    monitor[kMonitorId] = null;\n  }\n\n  if (monitor[kRTTPinger]) {\n    monitor[kRTTPinger].close();\n    monitor[kRTTPinger] = undefined;\n  }\n\n  monitor[kCancellationToken].emit('cancel');\n\n  if (monitor[kMonitorId]) {\n    clearTimeout(monitor[kMonitorId]);\n    monitor[kMonitorId] = undefined;\n  }\n\n  if (monitor[kConnection]) {\n    monitor[kConnection].destroy({\n      force: true\n    });\n  }\n}\n\nfunction checkServer(monitor, callback) {\n  let start = now();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    if (monitor[kConnection]) {\n      monitor[kConnection].destroy({\n        force: true\n      });\n      monitor[kConnection] = undefined;\n    }\n\n    monitor.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));\n    monitor.emit('resetServer', err);\n    monitor.emit('resetConnectionPool');\n    callback(err);\n  }\n\n  if (monitor[kConnection] != null && !monitor[kConnection].closed) {\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n    const cmd = isAwaitable ? {\n      ismaster: true,\n      maxAwaitTimeMS,\n      topologyVersion: makeTopologyVersion(topologyVersion)\n    } : {\n      ismaster: true\n    };\n    const options = isAwaitable ? {\n      socketTimeout: connectTimeoutMS + maxAwaitTimeMS,\n      exhaustAllowed: true\n    } : {\n      socketTimeout: connectTimeoutMS\n    };\n\n    if (isAwaitable && monitor[kRTTPinger] == null) {\n      monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);\n    }\n\n    monitor[kConnection].command('admin.$cmd', cmd, options, (err, result) => {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n\n      const isMaster = result.result;\n      const duration = isAwaitable ? monitor[kRTTPinger].roundTripTime : calculateDurationInMs(start);\n      monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address)); // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n\n      if (isAwaitable && isMaster.topologyVersion) {\n        monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n        start = now();\n      } else {\n        if (monitor[kRTTPinger]) {\n          monitor[kRTTPinger].close();\n          monitor[kRTTPinger] = undefined;\n        }\n\n        callback(undefined, isMaster);\n      }\n    });\n    return;\n  } // connecting does an implicit `ismaster`\n\n\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\n    if (conn && isInCloseState(monitor)) {\n      conn.destroy({\n        force: true\n      });\n      return;\n    }\n\n    if (err) {\n      monitor[kConnection] = undefined; // we already reset the connection pool on network errors in all cases\n\n      if (!(err instanceof MongoNetworkError)) {\n        monitor.emit('resetConnectionPool');\n      }\n\n      failureHandler(err);\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));\n    callback(undefined, conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  return callback => {\n    stateTransition(monitor, STATE_MONITORING);\n\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    } // TODO: the next line is a legacy event, remove in v4\n\n\n    process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\n    checkServer(monitor, (err, isMaster) => {\n      if (err) {\n        // otherwise an error occured on initial discovery, also bail\n        if (monitor[kServer].description.type === ServerType.Unknown) {\n          monitor.emit('resetServer', err);\n          return done();\n        }\n      } // if the check indicates streaming is supported, immediately reschedule monitoring\n\n\n      if (isMaster && isMaster.topologyVersion) {\n        setTimeout(() => {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId].wake();\n          }\n        });\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    counter: BSON.Long.fromNumber(tv.counter)\n  };\n}\n\nclass RTTPinger {\n  constructor(cancellationToken, options) {\n    this[kConnection] = null;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n\n  get roundTripTime() {\n    return this[kRoundTripTime];\n  }\n\n  close() {\n    this.closed = true;\n    clearTimeout(this[kMonitorId]);\n    this[kMonitorId] = undefined;\n\n    if (this[kConnection]) {\n      this[kConnection].destroy({\n        force: true\n      });\n    }\n  }\n\n}\n\nfunction measureRoundTripTime(rttPinger, options) {\n  const start = now();\n  const cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n\n  if (rttPinger.closed) {\n    return;\n  }\n\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn.destroy({\n        force: true\n      });\n      return;\n    }\n\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\n    rttPinger[kMonitorId] = setTimeout(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);\n  }\n\n  if (rttPinger[kConnection] == null) {\n    connect(options, cancellationToken, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n\n      measureAndReschedule(conn);\n    });\n    return;\n  }\n\n  rttPinger[kConnection].command('admin.$cmd', {\n    ismaster: 1\n  }, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n\n    measureAndReschedule();\n  });\n}\n\nmodule.exports = {\n  Monitor\n};","map":{"version":3,"sources":["/Users/rohanvarshney/Google Drive/GitHub/LostThenFound/lost-then-found/node_modules/mongodb/lib/core/sdam/monitor.js"],"names":["ServerType","require","EventEmitter","connect","Connection","common","makeStateMachine","MongoNetworkError","BSON","retrieveBSON","makeInterruptableAsyncInterval","calculateDurationInMs","now","sdamEvents","ServerHeartbeatStartedEvent","ServerHeartbeatSucceededEvent","ServerHeartbeatFailedEvent","kServer","Symbol","kMonitorId","kConnection","kCancellationToken","kRTTPinger","kRoundTripTime","STATE_CLOSED","STATE_CLOSING","STATE_IDLE","STATE_MONITORING","stateTransition","INVALID_REQUEST_CHECK_STATES","Set","isInCloseState","monitor","s","state","Monitor","constructor","server","options","undefined","setMaxListeners","Infinity","address","description","Object","freeze","connectTimeoutMS","connectionTimeout","heartbeatFrequencyMS","minHeartbeatFrequencyMS","connectOptions","assign","id","host","port","bson","connectionType","raw","promoteLongs","promoteValues","promoteBuffers","credentials","monitorServer","interval","minInterval","immediate","requestCheck","has","wake","reset","resetMonitorState","close","emit","stop","clearTimeout","destroy","force","checkServer","callback","start","failureHandler","err","closed","maxAwaitTimeMS","topologyVersion","isAwaitable","cmd","ismaster","makeTopologyVersion","socketTimeout","exhaustAllowed","RTTPinger","command","result","isMaster","duration","roundTripTime","conn","done","process","nextTick","type","Unknown","setTimeout","tv","processId","counter","Long","fromNumber","cancellationToken","measureRoundTripTime","rttPinger","measureAndReschedule","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst ServerType = require('./common').ServerType;\nconst EventEmitter = require('events');\nconst connect = require('../connection/connect');\nconst Connection = require('../../cmap/connection').Connection;\nconst common = require('./common');\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst BSON = require('../connection/utils').retrieveBSON();\nconst makeInterruptableAsyncInterval = require('../../utils').makeInterruptableAsyncInterval;\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\nconst now = require('../../utils').now;\n\nconst sdamEvents = require('./events');\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\n\nconst kServer = Symbol('server');\nconst kMonitorId = Symbol('monitorId');\nconst kConnection = Symbol('connection');\nconst kCancellationToken = Symbol('cancellationToken');\nconst kRTTPinger = Symbol('rttPinger');\nconst kRoundTripTime = Symbol('roundTripTime');\n\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\n\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nfunction isInCloseState(monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\nclass Monitor extends EventEmitter {\n  constructor(server, options) {\n    super(options);\n\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = null;\n    this.s = {\n      state: STATE_CLOSED\n    };\n\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS:\n        typeof options.connectionTimeout === 'number'\n          ? options.connectionTimeout\n          : typeof options.connectTimeoutMS === 'number'\n          ? options.connectTimeoutMS\n          : 10000,\n      heartbeatFrequencyMS:\n        typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS:\n        typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    });\n\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const connectOptions = Object.assign(\n      {\n        id: '<monitor>',\n        host: server.description.host,\n        port: server.description.port,\n        bson: server.s.bson,\n        connectionType: Connection\n      },\n      server.s.options,\n      this.options,\n\n      // force BSON serialization options\n      {\n        raw: false,\n        promoteLongs: true,\n        promoteValues: true,\n        promoteBuffers: true\n      }\n    );\n\n    // ensure no authentication is used for monitoring\n    delete connectOptions.credentials;\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    this[kMonitorId].wake();\n  }\n\n  reset() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // restart monitor\n    stateTransition(this, STATE_IDLE);\n\n    // restart monitoring\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS\n    });\n  }\n\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // close monitor\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n}\n\nfunction resetMonitorState(monitor) {\n  stateTransition(monitor, STATE_CLOSING);\n  if (monitor[kMonitorId]) {\n    monitor[kMonitorId].stop();\n    monitor[kMonitorId] = null;\n  }\n\n  if (monitor[kRTTPinger]) {\n    monitor[kRTTPinger].close();\n    monitor[kRTTPinger] = undefined;\n  }\n\n  monitor[kCancellationToken].emit('cancel');\n  if (monitor[kMonitorId]) {\n    clearTimeout(monitor[kMonitorId]);\n    monitor[kMonitorId] = undefined;\n  }\n\n  if (monitor[kConnection]) {\n    monitor[kConnection].destroy({ force: true });\n  }\n}\n\nfunction checkServer(monitor, callback) {\n  let start = now();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    if (monitor[kConnection]) {\n      monitor[kConnection].destroy({ force: true });\n      monitor[kConnection] = undefined;\n    }\n\n    monitor.emit(\n      'serverHeartbeatFailed',\n      new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address)\n    );\n\n    monitor.emit('resetServer', err);\n    monitor.emit('resetConnectionPool');\n    callback(err);\n  }\n\n  if (monitor[kConnection] != null && !monitor[kConnection].closed) {\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n\n    const cmd = isAwaitable\n      ? { ismaster: true, maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) }\n      : { ismaster: true };\n\n    const options = isAwaitable\n      ? { socketTimeout: connectTimeoutMS + maxAwaitTimeMS, exhaustAllowed: true }\n      : { socketTimeout: connectTimeoutMS };\n\n    if (isAwaitable && monitor[kRTTPinger] == null) {\n      monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);\n    }\n\n    monitor[kConnection].command('admin.$cmd', cmd, options, (err, result) => {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n\n      const isMaster = result.result;\n      const duration = isAwaitable\n        ? monitor[kRTTPinger].roundTripTime\n        : calculateDurationInMs(start);\n\n      monitor.emit(\n        'serverHeartbeatSucceeded',\n        new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address)\n      );\n\n      // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n      if (isAwaitable && isMaster.topologyVersion) {\n        monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n        start = now();\n      } else {\n        if (monitor[kRTTPinger]) {\n          monitor[kRTTPinger].close();\n          monitor[kRTTPinger] = undefined;\n        }\n\n        callback(undefined, isMaster);\n      }\n    });\n\n    return;\n  }\n\n  // connecting does an implicit `ismaster`\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\n    if (conn && isInCloseState(monitor)) {\n      conn.destroy({ force: true });\n      return;\n    }\n\n    if (err) {\n      monitor[kConnection] = undefined;\n\n      // we already reset the connection pool on network errors in all cases\n      if (!(err instanceof MongoNetworkError)) {\n        monitor.emit('resetConnectionPool');\n      }\n\n      failureHandler(err);\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    monitor.emit(\n      'serverHeartbeatSucceeded',\n      new ServerHeartbeatSucceededEvent(\n        calculateDurationInMs(start),\n        conn.ismaster,\n        monitor.address\n      )\n    );\n\n    callback(undefined, conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  return callback => {\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    }\n\n    // TODO: the next line is a legacy event, remove in v4\n    process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\n\n    checkServer(monitor, (err, isMaster) => {\n      if (err) {\n        // otherwise an error occured on initial discovery, also bail\n        if (monitor[kServer].description.type === ServerType.Unknown) {\n          monitor.emit('resetServer', err);\n          return done();\n        }\n      }\n\n      // if the check indicates streaming is supported, immediately reschedule monitoring\n      if (isMaster && isMaster.topologyVersion) {\n        setTimeout(() => {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId].wake();\n          }\n        });\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    counter: BSON.Long.fromNumber(tv.counter)\n  };\n}\n\nclass RTTPinger {\n  constructor(cancellationToken, options) {\n    this[kConnection] = null;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n\n  get roundTripTime() {\n    return this[kRoundTripTime];\n  }\n\n  close() {\n    this.closed = true;\n\n    clearTimeout(this[kMonitorId]);\n    this[kMonitorId] = undefined;\n\n    if (this[kConnection]) {\n      this[kConnection].destroy({ force: true });\n    }\n  }\n}\n\nfunction measureRoundTripTime(rttPinger, options) {\n  const start = now();\n  const cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n  if (rttPinger.closed) {\n    return;\n  }\n\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn.destroy({ force: true });\n      return;\n    }\n\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\n    rttPinger[kMonitorId] = setTimeout(\n      () => measureRoundTripTime(rttPinger, options),\n      heartbeatFrequencyMS\n    );\n  }\n\n  if (rttPinger[kConnection] == null) {\n    connect(options, cancellationToken, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n\n      measureAndReschedule(conn);\n    });\n\n    return;\n  }\n\n  rttPinger[kConnection].command('admin.$cmd', { ismaster: 1 }, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n\n    measureAndReschedule();\n  });\n}\n\nmodule.exports = {\n  Monitor\n};\n"]},"metadata":{},"sourceType":"script"}