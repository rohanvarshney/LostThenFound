{"ast":null,"code":"'use strict';\n\nconst OperationBase = require('./operation').OperationBase;\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst decorateWithCollation = require('../utils').decorateWithCollation;\n\nconst executeCommand = require('./db_ops').executeCommand;\n\nconst formattedOrderClause = require('../utils').formattedOrderClause;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\nconst MongoError = require('../error').MongoError;\n\nclass FindAndModifyOperation extends OperationBase {\n  constructor(collection, query, sort, doc, options) {\n    super(options);\n    this.collection = collection;\n    this.query = query;\n    this.sort = sort;\n    this.doc = doc;\n  }\n\n  execute(callback) {\n    const coll = this.collection;\n    const query = this.query;\n    const sort = formattedOrderClause(this.sort);\n    const doc = this.doc;\n    let options = this.options; // Create findAndModify command object\n\n    const queryObject = {\n      findAndModify: coll.collectionName,\n      query: query\n    };\n\n    if (sort) {\n      queryObject.sort = sort;\n    }\n\n    queryObject.new = options.new ? true : false;\n    queryObject.remove = options.remove ? true : false;\n    queryObject.upsert = options.upsert ? true : false;\n    const projection = options.projection || options.fields;\n\n    if (projection) {\n      queryObject.fields = projection;\n    }\n\n    if (options.arrayFilters) {\n      queryObject.arrayFilters = options.arrayFilters;\n    }\n\n    if (doc && !options.remove) {\n      queryObject.update = doc;\n    }\n\n    if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS; // Either use override on the function, or go back to default on either the collection\n    // level or db\n\n    options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions; // No check on the documents\n\n    options.checkKeys = false; // Final options for retryable writes and write concern\n\n    options = applyRetryableWrites(options, coll.s.db);\n    options = applyWriteConcern(options, {\n      db: coll.s.db,\n      collection: coll\n    }, options); // Decorate the findAndModify command with the write Concern\n\n    if (options.writeConcern) {\n      queryObject.writeConcern = options.writeConcern;\n    } // Have we specified bypassDocumentValidation\n\n\n    if (options.bypassDocumentValidation === true) {\n      queryObject.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    options.readPreference = ReadPreference.primary; // Have we specified collation\n\n    try {\n      decorateWithCollation(queryObject, coll, options);\n    } catch (err) {\n      return callback(err, null);\n    }\n\n    if (options.hint) {\n      // TODO: once this method becomes a CommandOperationV2 we will have the server\n      // in place to check.\n      const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;\n\n      if (unacknowledgedWrite || maxWireVersion(coll.s.topology) < 8) {\n        callback(new MongoError('The current topology does not support a hint on findAndModify commands'));\n        return;\n      }\n\n      queryObject.hint = options.hint;\n    } // Execute the command\n\n\n    executeCommand(coll.s.db, queryObject, options, (err, result) => {\n      if (err) return handleCallback(callback, err, null);\n      return handleCallback(callback, null, result);\n    });\n  }\n\n}\n\nmodule.exports = FindAndModifyOperation;","map":{"version":3,"sources":["/Users/rohanvarshney/Google Drive/GitHub/LostThenFound/lost-then-found/node_modules/mongodb/lib/operations/find_and_modify.js"],"names":["OperationBase","require","applyRetryableWrites","applyWriteConcern","decorateWithCollation","executeCommand","formattedOrderClause","handleCallback","ReadPreference","maxWireVersion","MongoError","FindAndModifyOperation","constructor","collection","query","sort","doc","options","execute","callback","coll","queryObject","findAndModify","collectionName","new","remove","upsert","projection","fields","arrayFilters","update","maxTimeMS","serializeFunctions","s","checkKeys","db","writeConcern","bypassDocumentValidation","readPreference","primary","err","hint","unacknowledgedWrite","w","topology","result","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst OperationBase = require('./operation').OperationBase;\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\nconst applyWriteConcern = require('../utils').applyWriteConcern;\nconst decorateWithCollation = require('../utils').decorateWithCollation;\nconst executeCommand = require('./db_ops').executeCommand;\nconst formattedOrderClause = require('../utils').formattedOrderClause;\nconst handleCallback = require('../utils').handleCallback;\nconst ReadPreference = require('../core').ReadPreference;\nconst maxWireVersion = require('../core/utils').maxWireVersion;\nconst MongoError = require('../error').MongoError;\n\nclass FindAndModifyOperation extends OperationBase {\n  constructor(collection, query, sort, doc, options) {\n    super(options);\n\n    this.collection = collection;\n    this.query = query;\n    this.sort = sort;\n    this.doc = doc;\n  }\n\n  execute(callback) {\n    const coll = this.collection;\n    const query = this.query;\n    const sort = formattedOrderClause(this.sort);\n    const doc = this.doc;\n    let options = this.options;\n\n    // Create findAndModify command object\n    const queryObject = {\n      findAndModify: coll.collectionName,\n      query: query\n    };\n\n    if (sort) {\n      queryObject.sort = sort;\n    }\n\n    queryObject.new = options.new ? true : false;\n    queryObject.remove = options.remove ? true : false;\n    queryObject.upsert = options.upsert ? true : false;\n\n    const projection = options.projection || options.fields;\n\n    if (projection) {\n      queryObject.fields = projection;\n    }\n\n    if (options.arrayFilters) {\n      queryObject.arrayFilters = options.arrayFilters;\n    }\n\n    if (doc && !options.remove) {\n      queryObject.update = doc;\n    }\n\n    if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS;\n\n    // Either use override on the function, or go back to default on either the collection\n    // level or db\n    options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\n\n    // No check on the documents\n    options.checkKeys = false;\n\n    // Final options for retryable writes and write concern\n    options = applyRetryableWrites(options, coll.s.db);\n    options = applyWriteConcern(options, { db: coll.s.db, collection: coll }, options);\n\n    // Decorate the findAndModify command with the write Concern\n    if (options.writeConcern) {\n      queryObject.writeConcern = options.writeConcern;\n    }\n\n    // Have we specified bypassDocumentValidation\n    if (options.bypassDocumentValidation === true) {\n      queryObject.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    options.readPreference = ReadPreference.primary;\n\n    // Have we specified collation\n    try {\n      decorateWithCollation(queryObject, coll, options);\n    } catch (err) {\n      return callback(err, null);\n    }\n\n    if (options.hint) {\n      // TODO: once this method becomes a CommandOperationV2 we will have the server\n      // in place to check.\n      const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;\n      if (unacknowledgedWrite || maxWireVersion(coll.s.topology) < 8) {\n        callback(\n          new MongoError('The current topology does not support a hint on findAndModify commands')\n        );\n\n        return;\n      }\n\n      queryObject.hint = options.hint;\n    }\n\n    // Execute the command\n    executeCommand(coll.s.db, queryObject, options, (err, result) => {\n      if (err) return handleCallback(callback, err, null);\n\n      return handleCallback(callback, null, result);\n    });\n  }\n}\n\nmodule.exports = FindAndModifyOperation;\n"]},"metadata":{},"sourceType":"script"}