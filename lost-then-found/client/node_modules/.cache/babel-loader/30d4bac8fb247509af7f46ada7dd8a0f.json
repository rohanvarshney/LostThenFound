{"ast":null,"code":"'use strict';\n\nvar core = require('../core');\n\nvar crypto = require('crypto');\n\nvar stream = require('stream');\n\nvar util = require('util');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar ERROR_NAMESPACE_NOT_FOUND = 26;\nmodule.exports = GridFSBucketWriteStream;\n/**\n * A writable stream that enables you to write buffers to GridFS.\n *\n * Do not instantiate this class directly. Use `openUploadStream()` instead.\n *\n * @class\n * @extends external:Writable\n * @param {GridFSBucket} bucket Handle for this stream's corresponding bucket\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options] Optional settings.\n * @param {string|number|object} [options.id] Custom file id for the GridFS file.\n * @param {number} [options.chunkSizeBytes] The chunk size to use, in bytes\n * @param {number} [options.w] The write concern\n * @param {number} [options.wtimeout] The write concern timeout\n * @param {number} [options.j] The journal write concern\n * @param {boolean} [options.disableMD5=false] If true, disables adding an md5 field to file data\n * @fires GridFSBucketWriteStream#error\n * @fires GridFSBucketWriteStream#finish\n */\n\nfunction GridFSBucketWriteStream(bucket, filename, options) {\n  options = options || {};\n  this.bucket = bucket;\n  this.chunks = bucket.s._chunksCollection;\n  this.filename = filename;\n  this.files = bucket.s._filesCollection;\n  this.options = options; // Signals the write is all done\n\n  this.done = false;\n  this.id = options.id ? options.id : core.BSON.ObjectId();\n  this.chunkSizeBytes = this.options.chunkSizeBytes;\n  this.bufToStore = Buffer.alloc(this.chunkSizeBytes);\n  this.length = 0;\n  this.md5 = !options.disableMD5 && crypto.createHash('md5');\n  this.n = 0;\n  this.pos = 0;\n  this.state = {\n    streamEnd: false,\n    outstandingRequests: 0,\n    errored: false,\n    aborted: false,\n    promiseLibrary: this.bucket.s.promiseLibrary\n  };\n\n  if (!this.bucket.s.calledOpenUploadStream) {\n    this.bucket.s.calledOpenUploadStream = true;\n\n    var _this = this;\n\n    checkIndexes(this, function () {\n      _this.bucket.s.checkedIndexes = true;\n\n      _this.bucket.emit('index');\n    });\n  }\n}\n\nutil.inherits(GridFSBucketWriteStream, stream.Writable);\n/**\n * An error occurred\n *\n * @event GridFSBucketWriteStream#error\n * @type {Error}\n */\n\n/**\n * `end()` was called and the write stream successfully wrote the file\n * metadata and all the chunks to MongoDB.\n *\n * @event GridFSBucketWriteStream#finish\n * @type {object}\n */\n\n/**\n * Write a buffer to the stream.\n *\n * @method\n * @param {Buffer} chunk Buffer to write\n * @param {String} encoding Optional encoding for the buffer\n * @param {GridFSBucket~errorCallback} callback Function to call when the chunk was added to the buffer, or if the entire chunk was persisted to MongoDB if this chunk caused a flush.\n * @return {Boolean} False if this write required flushing a chunk to MongoDB. True otherwise.\n */\n\nGridFSBucketWriteStream.prototype.write = function (chunk, encoding, callback) {\n  var _this = this;\n\n  return waitForIndexes(this, function () {\n    return doWrite(_this, chunk, encoding, callback);\n  });\n};\n/**\n * Places this write stream into an aborted state (all future writes fail)\n * and deletes all chunks that have already been written.\n *\n * @method\n * @param {GridFSBucket~errorCallback} callback called when chunks are successfully removed or error occurred\n * @return {Promise} if no callback specified\n */\n\n\nGridFSBucketWriteStream.prototype.abort = function (callback) {\n  if (this.state.streamEnd) {\n    var error = new Error('Cannot abort a stream that has already completed');\n\n    if (typeof callback === 'function') {\n      return callback(error);\n    }\n\n    return this.state.promiseLibrary.reject(error);\n  }\n\n  if (this.state.aborted) {\n    error = new Error('Cannot call abort() on a stream twice');\n\n    if (typeof callback === 'function') {\n      return callback(error);\n    }\n\n    return this.state.promiseLibrary.reject(error);\n  }\n\n  this.state.aborted = true;\n  this.chunks.deleteMany({\n    files_id: this.id\n  }, function (error) {\n    if (typeof callback === 'function') callback(error);\n  });\n};\n/**\n * Tells the stream that no more data will be coming in. The stream will\n * persist the remaining data to MongoDB, write the files document, and\n * then emit a 'finish' event.\n *\n * @method\n * @param {Buffer} chunk Buffer to write\n * @param {String} encoding Optional encoding for the buffer\n * @param {GridFSBucket~errorCallback} callback Function to call when all files and chunks have been persisted to MongoDB\n */\n\n\nGridFSBucketWriteStream.prototype.end = function (chunk, encoding, callback) {\n  var _this = this;\n\n  if (typeof chunk === 'function') {\n    callback = chunk, chunk = null, encoding = null;\n  } else if (typeof encoding === 'function') {\n    callback = encoding, encoding = null;\n  }\n\n  if (checkAborted(this, callback)) {\n    return;\n  }\n\n  this.state.streamEnd = true;\n\n  if (callback) {\n    this.once('finish', function (result) {\n      callback(null, result);\n    });\n  }\n\n  if (!chunk) {\n    waitForIndexes(this, function () {\n      writeRemnant(_this);\n    });\n    return;\n  }\n\n  this.write(chunk, encoding, function () {\n    writeRemnant(_this);\n  });\n};\n/**\n * @ignore\n */\n\n\nfunction __handleError(_this, error, callback) {\n  if (_this.state.errored) {\n    return;\n  }\n\n  _this.state.errored = true;\n\n  if (callback) {\n    return callback(error);\n  }\n\n  _this.emit('error', error);\n}\n/**\n * @ignore\n */\n\n\nfunction createChunkDoc(filesId, n, data) {\n  return {\n    _id: core.BSON.ObjectId(),\n    files_id: filesId,\n    n: n,\n    data: data\n  };\n}\n/**\n * @ignore\n */\n\n\nfunction checkChunksIndex(_this, callback) {\n  _this.chunks.listIndexes().toArray(function (error, indexes) {\n    if (error) {\n      // Collection doesn't exist so create index\n      if (error.code === ERROR_NAMESPACE_NOT_FOUND) {\n        var index = {\n          files_id: 1,\n          n: 1\n        };\n\n        _this.chunks.createIndex(index, {\n          background: false,\n          unique: true\n        }, function (error) {\n          if (error) {\n            return callback(error);\n          }\n\n          callback();\n        });\n\n        return;\n      }\n\n      return callback(error);\n    }\n\n    var hasChunksIndex = false;\n    indexes.forEach(function (index) {\n      if (index.key) {\n        var keys = Object.keys(index.key);\n\n        if (keys.length === 2 && index.key.files_id === 1 && index.key.n === 1) {\n          hasChunksIndex = true;\n        }\n      }\n    });\n\n    if (hasChunksIndex) {\n      callback();\n    } else {\n      index = {\n        files_id: 1,\n        n: 1\n      };\n      var indexOptions = getWriteOptions(_this);\n      indexOptions.background = false;\n      indexOptions.unique = true;\n\n      _this.chunks.createIndex(index, indexOptions, function (error) {\n        if (error) {\n          return callback(error);\n        }\n\n        callback();\n      });\n    }\n  });\n}\n/**\n * @ignore\n */\n\n\nfunction checkDone(_this, callback) {\n  if (_this.done) return true;\n\n  if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {\n    // Set done so we dont' trigger duplicate createFilesDoc\n    _this.done = true; // Create a new files doc\n\n    var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes, _this.md5 && _this.md5.digest('hex'), _this.filename, _this.options.contentType, _this.options.aliases, _this.options.metadata);\n\n    if (checkAborted(_this, callback)) {\n      return false;\n    }\n\n    _this.files.insertOne(filesDoc, getWriteOptions(_this), function (error) {\n      if (error) {\n        return __handleError(_this, error, callback);\n      }\n\n      _this.emit('finish', filesDoc);\n    });\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * @ignore\n */\n\n\nfunction checkIndexes(_this, callback) {\n  _this.files.findOne({}, {\n    _id: 1\n  }, function (error, doc) {\n    if (error) {\n      return callback(error);\n    }\n\n    if (doc) {\n      return callback();\n    }\n\n    _this.files.listIndexes().toArray(function (error, indexes) {\n      if (error) {\n        // Collection doesn't exist so create index\n        if (error.code === ERROR_NAMESPACE_NOT_FOUND) {\n          var index = {\n            filename: 1,\n            uploadDate: 1\n          };\n\n          _this.files.createIndex(index, {\n            background: false\n          }, function (error) {\n            if (error) {\n              return callback(error);\n            }\n\n            checkChunksIndex(_this, callback);\n          });\n\n          return;\n        }\n\n        return callback(error);\n      }\n\n      var hasFileIndex = false;\n      indexes.forEach(function (index) {\n        var keys = Object.keys(index.key);\n\n        if (keys.length === 2 && index.key.filename === 1 && index.key.uploadDate === 1) {\n          hasFileIndex = true;\n        }\n      });\n\n      if (hasFileIndex) {\n        checkChunksIndex(_this, callback);\n      } else {\n        index = {\n          filename: 1,\n          uploadDate: 1\n        };\n        var indexOptions = getWriteOptions(_this);\n        indexOptions.background = false;\n\n        _this.files.createIndex(index, indexOptions, function (error) {\n          if (error) {\n            return callback(error);\n          }\n\n          checkChunksIndex(_this, callback);\n        });\n      }\n    });\n  });\n}\n/**\n * @ignore\n */\n\n\nfunction createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {\n  var ret = {\n    _id: _id,\n    length: length,\n    chunkSize: chunkSize,\n    uploadDate: new Date(),\n    filename: filename\n  };\n\n  if (md5) {\n    ret.md5 = md5;\n  }\n\n  if (contentType) {\n    ret.contentType = contentType;\n  }\n\n  if (aliases) {\n    ret.aliases = aliases;\n  }\n\n  if (metadata) {\n    ret.metadata = metadata;\n  }\n\n  return ret;\n}\n/**\n * @ignore\n */\n\n\nfunction doWrite(_this, chunk, encoding, callback) {\n  if (checkAborted(_this, callback)) {\n    return false;\n  }\n\n  var inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);\n  _this.length += inputBuf.length; // Input is small enough to fit in our buffer\n\n  if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {\n    inputBuf.copy(_this.bufToStore, _this.pos);\n    _this.pos += inputBuf.length;\n    callback && callback(); // Note that we reverse the typical semantics of write's return value\n    // to be compatible with node's `.pipe()` function.\n    // True means client can keep writing.\n\n    return true;\n  } // Otherwise, buffer is too big for current chunk, so we need to flush\n  // to MongoDB.\n\n\n  var inputBufRemaining = inputBuf.length;\n  var spaceRemaining = _this.chunkSizeBytes - _this.pos;\n  var numToCopy = Math.min(spaceRemaining, inputBuf.length);\n  var outstandingRequests = 0;\n\n  while (inputBufRemaining > 0) {\n    var inputBufPos = inputBuf.length - inputBufRemaining;\n    inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);\n    _this.pos += numToCopy;\n    spaceRemaining -= numToCopy;\n\n    if (spaceRemaining === 0) {\n      if (_this.md5) {\n        _this.md5.update(_this.bufToStore);\n      }\n\n      var doc = createChunkDoc(_this.id, _this.n, Buffer.from(_this.bufToStore));\n      ++_this.state.outstandingRequests;\n      ++outstandingRequests;\n\n      if (checkAborted(_this, callback)) {\n        return false;\n      }\n\n      _this.chunks.insertOne(doc, getWriteOptions(_this), function (error) {\n        if (error) {\n          return __handleError(_this, error);\n        }\n\n        --_this.state.outstandingRequests;\n        --outstandingRequests;\n\n        if (!outstandingRequests) {\n          _this.emit('drain', doc);\n\n          callback && callback();\n          checkDone(_this);\n        }\n      });\n\n      spaceRemaining = _this.chunkSizeBytes;\n      _this.pos = 0;\n      ++_this.n;\n    }\n\n    inputBufRemaining -= numToCopy;\n    numToCopy = Math.min(spaceRemaining, inputBufRemaining);\n  } // Note that we reverse the typical semantics of write's return value\n  // to be compatible with node's `.pipe()` function.\n  // False means the client should wait for the 'drain' event.\n\n\n  return false;\n}\n/**\n * @ignore\n */\n\n\nfunction getWriteOptions(_this) {\n  var obj = {};\n\n  if (_this.options.writeConcern) {\n    obj.w = _this.options.writeConcern.w;\n    obj.wtimeout = _this.options.writeConcern.wtimeout;\n    obj.j = _this.options.writeConcern.j;\n  }\n\n  return obj;\n}\n/**\n * @ignore\n */\n\n\nfunction waitForIndexes(_this, callback) {\n  if (_this.bucket.s.checkedIndexes) {\n    return callback(false);\n  }\n\n  _this.bucket.once('index', function () {\n    callback(true);\n  });\n\n  return true;\n}\n/**\n * @ignore\n */\n\n\nfunction writeRemnant(_this, callback) {\n  // Buffer is empty, so don't bother to insert\n  if (_this.pos === 0) {\n    return checkDone(_this, callback);\n  }\n\n  ++_this.state.outstandingRequests; // Create a new buffer to make sure the buffer isn't bigger than it needs\n  // to be.\n\n  var remnant = Buffer.alloc(_this.pos);\n\n  _this.bufToStore.copy(remnant, 0, 0, _this.pos);\n\n  if (_this.md5) {\n    _this.md5.update(remnant);\n  }\n\n  var doc = createChunkDoc(_this.id, _this.n, remnant); // If the stream was aborted, do not write remnant\n\n  if (checkAborted(_this, callback)) {\n    return false;\n  }\n\n  _this.chunks.insertOne(doc, getWriteOptions(_this), function (error) {\n    if (error) {\n      return __handleError(_this, error);\n    }\n\n    --_this.state.outstandingRequests;\n    checkDone(_this);\n  });\n}\n/**\n * @ignore\n */\n\n\nfunction checkAborted(_this, callback) {\n  if (_this.state.aborted) {\n    if (typeof callback === 'function') {\n      callback(new Error('this stream has been aborted'));\n    }\n\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/rohanvarshney/Google Drive/GitHub/LostThenFound/lost-then-found/node_modules/mongodb/lib/gridfs-stream/upload.js"],"names":["core","require","crypto","stream","util","Buffer","ERROR_NAMESPACE_NOT_FOUND","module","exports","GridFSBucketWriteStream","bucket","filename","options","chunks","s","_chunksCollection","files","_filesCollection","done","id","BSON","ObjectId","chunkSizeBytes","bufToStore","alloc","length","md5","disableMD5","createHash","n","pos","state","streamEnd","outstandingRequests","errored","aborted","promiseLibrary","calledOpenUploadStream","_this","checkIndexes","checkedIndexes","emit","inherits","Writable","prototype","write","chunk","encoding","callback","waitForIndexes","doWrite","abort","error","Error","reject","deleteMany","files_id","end","checkAborted","once","result","writeRemnant","__handleError","createChunkDoc","filesId","data","_id","checkChunksIndex","listIndexes","toArray","indexes","code","index","createIndex","background","unique","hasChunksIndex","forEach","key","keys","Object","indexOptions","getWriteOptions","checkDone","filesDoc","createFilesDoc","digest","contentType","aliases","metadata","insertOne","findOne","doc","uploadDate","hasFileIndex","chunkSize","ret","Date","inputBuf","isBuffer","from","copy","inputBufRemaining","spaceRemaining","numToCopy","Math","min","inputBufPos","update","obj","writeConcern","w","wtimeout","j","remnant"],"mappings":"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","sourcesContent":["'use strict';\n\nvar core = require('../core');\nvar crypto = require('crypto');\nvar stream = require('stream');\nvar util = require('util');\nvar Buffer = require('safe-buffer').Buffer;\n\nvar ERROR_NAMESPACE_NOT_FOUND = 26;\n\nmodule.exports = GridFSBucketWriteStream;\n\n/**\n * A writable stream that enables you to write buffers to GridFS.\n *\n * Do not instantiate this class directly. Use `openUploadStream()` instead.\n *\n * @class\n * @extends external:Writable\n * @param {GridFSBucket} bucket Handle for this stream's corresponding bucket\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options] Optional settings.\n * @param {string|number|object} [options.id] Custom file id for the GridFS file.\n * @param {number} [options.chunkSizeBytes] The chunk size to use, in bytes\n * @param {number} [options.w] The write concern\n * @param {number} [options.wtimeout] The write concern timeout\n * @param {number} [options.j] The journal write concern\n * @param {boolean} [options.disableMD5=false] If true, disables adding an md5 field to file data\n * @fires GridFSBucketWriteStream#error\n * @fires GridFSBucketWriteStream#finish\n */\n\nfunction GridFSBucketWriteStream(bucket, filename, options) {\n  options = options || {};\n  this.bucket = bucket;\n  this.chunks = bucket.s._chunksCollection;\n  this.filename = filename;\n  this.files = bucket.s._filesCollection;\n  this.options = options;\n  // Signals the write is all done\n  this.done = false;\n\n  this.id = options.id ? options.id : core.BSON.ObjectId();\n  this.chunkSizeBytes = this.options.chunkSizeBytes;\n  this.bufToStore = Buffer.alloc(this.chunkSizeBytes);\n  this.length = 0;\n  this.md5 = !options.disableMD5 && crypto.createHash('md5');\n  this.n = 0;\n  this.pos = 0;\n  this.state = {\n    streamEnd: false,\n    outstandingRequests: 0,\n    errored: false,\n    aborted: false,\n    promiseLibrary: this.bucket.s.promiseLibrary\n  };\n\n  if (!this.bucket.s.calledOpenUploadStream) {\n    this.bucket.s.calledOpenUploadStream = true;\n\n    var _this = this;\n    checkIndexes(this, function() {\n      _this.bucket.s.checkedIndexes = true;\n      _this.bucket.emit('index');\n    });\n  }\n}\n\nutil.inherits(GridFSBucketWriteStream, stream.Writable);\n\n/**\n * An error occurred\n *\n * @event GridFSBucketWriteStream#error\n * @type {Error}\n */\n\n/**\n * `end()` was called and the write stream successfully wrote the file\n * metadata and all the chunks to MongoDB.\n *\n * @event GridFSBucketWriteStream#finish\n * @type {object}\n */\n\n/**\n * Write a buffer to the stream.\n *\n * @method\n * @param {Buffer} chunk Buffer to write\n * @param {String} encoding Optional encoding for the buffer\n * @param {GridFSBucket~errorCallback} callback Function to call when the chunk was added to the buffer, or if the entire chunk was persisted to MongoDB if this chunk caused a flush.\n * @return {Boolean} False if this write required flushing a chunk to MongoDB. True otherwise.\n */\n\nGridFSBucketWriteStream.prototype.write = function(chunk, encoding, callback) {\n  var _this = this;\n  return waitForIndexes(this, function() {\n    return doWrite(_this, chunk, encoding, callback);\n  });\n};\n\n/**\n * Places this write stream into an aborted state (all future writes fail)\n * and deletes all chunks that have already been written.\n *\n * @method\n * @param {GridFSBucket~errorCallback} callback called when chunks are successfully removed or error occurred\n * @return {Promise} if no callback specified\n */\n\nGridFSBucketWriteStream.prototype.abort = function(callback) {\n  if (this.state.streamEnd) {\n    var error = new Error('Cannot abort a stream that has already completed');\n    if (typeof callback === 'function') {\n      return callback(error);\n    }\n    return this.state.promiseLibrary.reject(error);\n  }\n  if (this.state.aborted) {\n    error = new Error('Cannot call abort() on a stream twice');\n    if (typeof callback === 'function') {\n      return callback(error);\n    }\n    return this.state.promiseLibrary.reject(error);\n  }\n  this.state.aborted = true;\n  this.chunks.deleteMany({ files_id: this.id }, function(error) {\n    if (typeof callback === 'function') callback(error);\n  });\n};\n\n/**\n * Tells the stream that no more data will be coming in. The stream will\n * persist the remaining data to MongoDB, write the files document, and\n * then emit a 'finish' event.\n *\n * @method\n * @param {Buffer} chunk Buffer to write\n * @param {String} encoding Optional encoding for the buffer\n * @param {GridFSBucket~errorCallback} callback Function to call when all files and chunks have been persisted to MongoDB\n */\n\nGridFSBucketWriteStream.prototype.end = function(chunk, encoding, callback) {\n  var _this = this;\n  if (typeof chunk === 'function') {\n    (callback = chunk), (chunk = null), (encoding = null);\n  } else if (typeof encoding === 'function') {\n    (callback = encoding), (encoding = null);\n  }\n\n  if (checkAborted(this, callback)) {\n    return;\n  }\n  this.state.streamEnd = true;\n\n  if (callback) {\n    this.once('finish', function(result) {\n      callback(null, result);\n    });\n  }\n\n  if (!chunk) {\n    waitForIndexes(this, function() {\n      writeRemnant(_this);\n    });\n    return;\n  }\n\n  this.write(chunk, encoding, function() {\n    writeRemnant(_this);\n  });\n};\n\n/**\n * @ignore\n */\n\nfunction __handleError(_this, error, callback) {\n  if (_this.state.errored) {\n    return;\n  }\n  _this.state.errored = true;\n  if (callback) {\n    return callback(error);\n  }\n  _this.emit('error', error);\n}\n\n/**\n * @ignore\n */\n\nfunction createChunkDoc(filesId, n, data) {\n  return {\n    _id: core.BSON.ObjectId(),\n    files_id: filesId,\n    n: n,\n    data: data\n  };\n}\n\n/**\n * @ignore\n */\n\nfunction checkChunksIndex(_this, callback) {\n  _this.chunks.listIndexes().toArray(function(error, indexes) {\n    if (error) {\n      // Collection doesn't exist so create index\n      if (error.code === ERROR_NAMESPACE_NOT_FOUND) {\n        var index = { files_id: 1, n: 1 };\n        _this.chunks.createIndex(index, { background: false, unique: true }, function(error) {\n          if (error) {\n            return callback(error);\n          }\n\n          callback();\n        });\n        return;\n      }\n      return callback(error);\n    }\n\n    var hasChunksIndex = false;\n    indexes.forEach(function(index) {\n      if (index.key) {\n        var keys = Object.keys(index.key);\n        if (keys.length === 2 && index.key.files_id === 1 && index.key.n === 1) {\n          hasChunksIndex = true;\n        }\n      }\n    });\n\n    if (hasChunksIndex) {\n      callback();\n    } else {\n      index = { files_id: 1, n: 1 };\n      var indexOptions = getWriteOptions(_this);\n\n      indexOptions.background = false;\n      indexOptions.unique = true;\n\n      _this.chunks.createIndex(index, indexOptions, function(error) {\n        if (error) {\n          return callback(error);\n        }\n\n        callback();\n      });\n    }\n  });\n}\n\n/**\n * @ignore\n */\n\nfunction checkDone(_this, callback) {\n  if (_this.done) return true;\n  if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {\n    // Set done so we dont' trigger duplicate createFilesDoc\n    _this.done = true;\n    // Create a new files doc\n    var filesDoc = createFilesDoc(\n      _this.id,\n      _this.length,\n      _this.chunkSizeBytes,\n      _this.md5 && _this.md5.digest('hex'),\n      _this.filename,\n      _this.options.contentType,\n      _this.options.aliases,\n      _this.options.metadata\n    );\n\n    if (checkAborted(_this, callback)) {\n      return false;\n    }\n\n    _this.files.insertOne(filesDoc, getWriteOptions(_this), function(error) {\n      if (error) {\n        return __handleError(_this, error, callback);\n      }\n      _this.emit('finish', filesDoc);\n    });\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * @ignore\n */\n\nfunction checkIndexes(_this, callback) {\n  _this.files.findOne({}, { _id: 1 }, function(error, doc) {\n    if (error) {\n      return callback(error);\n    }\n    if (doc) {\n      return callback();\n    }\n\n    _this.files.listIndexes().toArray(function(error, indexes) {\n      if (error) {\n        // Collection doesn't exist so create index\n        if (error.code === ERROR_NAMESPACE_NOT_FOUND) {\n          var index = { filename: 1, uploadDate: 1 };\n          _this.files.createIndex(index, { background: false }, function(error) {\n            if (error) {\n              return callback(error);\n            }\n\n            checkChunksIndex(_this, callback);\n          });\n          return;\n        }\n        return callback(error);\n      }\n\n      var hasFileIndex = false;\n      indexes.forEach(function(index) {\n        var keys = Object.keys(index.key);\n        if (keys.length === 2 && index.key.filename === 1 && index.key.uploadDate === 1) {\n          hasFileIndex = true;\n        }\n      });\n\n      if (hasFileIndex) {\n        checkChunksIndex(_this, callback);\n      } else {\n        index = { filename: 1, uploadDate: 1 };\n\n        var indexOptions = getWriteOptions(_this);\n\n        indexOptions.background = false;\n\n        _this.files.createIndex(index, indexOptions, function(error) {\n          if (error) {\n            return callback(error);\n          }\n\n          checkChunksIndex(_this, callback);\n        });\n      }\n    });\n  });\n}\n\n/**\n * @ignore\n */\n\nfunction createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {\n  var ret = {\n    _id: _id,\n    length: length,\n    chunkSize: chunkSize,\n    uploadDate: new Date(),\n    filename: filename\n  };\n\n  if (md5) {\n    ret.md5 = md5;\n  }\n\n  if (contentType) {\n    ret.contentType = contentType;\n  }\n\n  if (aliases) {\n    ret.aliases = aliases;\n  }\n\n  if (metadata) {\n    ret.metadata = metadata;\n  }\n\n  return ret;\n}\n\n/**\n * @ignore\n */\n\nfunction doWrite(_this, chunk, encoding, callback) {\n  if (checkAborted(_this, callback)) {\n    return false;\n  }\n\n  var inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);\n\n  _this.length += inputBuf.length;\n\n  // Input is small enough to fit in our buffer\n  if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {\n    inputBuf.copy(_this.bufToStore, _this.pos);\n    _this.pos += inputBuf.length;\n\n    callback && callback();\n\n    // Note that we reverse the typical semantics of write's return value\n    // to be compatible with node's `.pipe()` function.\n    // True means client can keep writing.\n    return true;\n  }\n\n  // Otherwise, buffer is too big for current chunk, so we need to flush\n  // to MongoDB.\n  var inputBufRemaining = inputBuf.length;\n  var spaceRemaining = _this.chunkSizeBytes - _this.pos;\n  var numToCopy = Math.min(spaceRemaining, inputBuf.length);\n  var outstandingRequests = 0;\n  while (inputBufRemaining > 0) {\n    var inputBufPos = inputBuf.length - inputBufRemaining;\n    inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);\n    _this.pos += numToCopy;\n    spaceRemaining -= numToCopy;\n    if (spaceRemaining === 0) {\n      if (_this.md5) {\n        _this.md5.update(_this.bufToStore);\n      }\n      var doc = createChunkDoc(_this.id, _this.n, Buffer.from(_this.bufToStore));\n      ++_this.state.outstandingRequests;\n      ++outstandingRequests;\n\n      if (checkAborted(_this, callback)) {\n        return false;\n      }\n\n      _this.chunks.insertOne(doc, getWriteOptions(_this), function(error) {\n        if (error) {\n          return __handleError(_this, error);\n        }\n        --_this.state.outstandingRequests;\n        --outstandingRequests;\n\n        if (!outstandingRequests) {\n          _this.emit('drain', doc);\n          callback && callback();\n          checkDone(_this);\n        }\n      });\n\n      spaceRemaining = _this.chunkSizeBytes;\n      _this.pos = 0;\n      ++_this.n;\n    }\n    inputBufRemaining -= numToCopy;\n    numToCopy = Math.min(spaceRemaining, inputBufRemaining);\n  }\n\n  // Note that we reverse the typical semantics of write's return value\n  // to be compatible with node's `.pipe()` function.\n  // False means the client should wait for the 'drain' event.\n  return false;\n}\n\n/**\n * @ignore\n */\n\nfunction getWriteOptions(_this) {\n  var obj = {};\n  if (_this.options.writeConcern) {\n    obj.w = _this.options.writeConcern.w;\n    obj.wtimeout = _this.options.writeConcern.wtimeout;\n    obj.j = _this.options.writeConcern.j;\n  }\n  return obj;\n}\n\n/**\n * @ignore\n */\n\nfunction waitForIndexes(_this, callback) {\n  if (_this.bucket.s.checkedIndexes) {\n    return callback(false);\n  }\n\n  _this.bucket.once('index', function() {\n    callback(true);\n  });\n\n  return true;\n}\n\n/**\n * @ignore\n */\n\nfunction writeRemnant(_this, callback) {\n  // Buffer is empty, so don't bother to insert\n  if (_this.pos === 0) {\n    return checkDone(_this, callback);\n  }\n\n  ++_this.state.outstandingRequests;\n\n  // Create a new buffer to make sure the buffer isn't bigger than it needs\n  // to be.\n  var remnant = Buffer.alloc(_this.pos);\n  _this.bufToStore.copy(remnant, 0, 0, _this.pos);\n  if (_this.md5) {\n    _this.md5.update(remnant);\n  }\n  var doc = createChunkDoc(_this.id, _this.n, remnant);\n\n  // If the stream was aborted, do not write remnant\n  if (checkAborted(_this, callback)) {\n    return false;\n  }\n\n  _this.chunks.insertOne(doc, getWriteOptions(_this), function(error) {\n    if (error) {\n      return __handleError(_this, error);\n    }\n    --_this.state.outstandingRequests;\n    checkDone(_this);\n  });\n}\n\n/**\n * @ignore\n */\n\nfunction checkAborted(_this, callback) {\n  if (_this.state.aborted) {\n    if (typeof callback === 'function') {\n      callback(new Error('this stream has been aborted'));\n    }\n    return true;\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}